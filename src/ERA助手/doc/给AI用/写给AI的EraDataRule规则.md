### EraDataRule 构建指南

#### 1. 核心概念 (Core Concepts)

`EraDataRule` 是一种用于**声明式数据处理**的规则引擎。其核心思想是，将复杂的数据变更逻辑从程序代码中分离出来，定义在一个结构化的JSON文件中。

- **目标**：对一个JSON格式的“游戏状态”或“数据对象”进行可预测、可追溯的修改。
- **参与者**：
  - **`snap` (快照)**：变更前的原始数据状态。
  - **`data` (增量)**：本次传入的、需要合并的数据变更。
  - **`workingData` (工作数据)**：`snap` 和 `data` 合并后的完整数据对象，是所有规则操作的直接目标。
  - **`rules` (规则集)**：定义了如何从 `workingData` 的初始状态演变到最终状态的一系列指令。
- **最终产物**：一个 `diff` 对象，仅包含 `workingData` 相对于原始 `snap` 发生变化的部分。

#### 2. 规则文件结构 (File Structure)

一个完整的 `EraDataRule` 文件是一个JSON对象，其顶层结构如下：

```json
{
  "version": "1.0",
  "exportDate": "2025-12-12T07:51:38.821Z",
  "rulesCount": 4,
  "rules": {
    "规则名称1": { ... },
    "规则名称2": { ... },
    ...
  }
}
```

- `version` (string): 规则文件的版本号。
- `exportDate` (string): 文件导出日期，元数据。
- `rulesCount` (number): 规则总数，元数据。
- `rules` (object): **核心部分**。一个字典（key-value object），其中：
  - **`key`** 是一个人类可读的、唯一的**规则名称** (e.g., "升级身体开发等级")。
  - **`value`** 是一个**规则对象**，定义了该规则的具体行为。

#### 3. 规则对象详解 (Rule Object Deep Dive)

每个规则对象都包含以下字段，用于精确控制其行为：

| 字段 | 类型 | 是否必须 | 描述 |
| :--- | :--- | :--- | :--- |
| `enable` | boolean | 否 (默认 `true`) | 控制此规则是否启用。`false` 则完全跳过此规则。 |
| `path` | string | 是 | **规则的作用域**。定义了规则将要操作的数据路径。这是一个关键字段，它决定了规则的执行模式。 |
| `order` | number | 否 (默认 `0`) | **执行顺序**。数字越小，规则越先执行。这是全局规则排序的依据。 |
| `if` | string | 否 | **规则级条件**。一个DSL表达式。只有当此条件为真时，规则的`handle`和`loop`才会生效。支持 `&&`, `||` 逻辑运算和 `()` 优先级。 |
| `loop` | number | 否 (默认 `1`) | **规则级循环**。指定整个规则需要重复执行的次数（最大`1000`）。若`if`表达式为假，则**立即终止**循环。 |
| `handle` | object | 否 | **核心操作**。一个包含多个“处理项”的字典，用于执行具体的数据修改。 |
| `limit` | `[number, number]` | 否 | **增量限制**。一个二元数组`[minDelta, maxDelta]`。在`handle`和`range`执行后，用于限制`path`对应的值相对于`snap`的**变化量**。仅在**作用域模式**下生效。 |
| `range` | `[number, number]` | 否 | **范围限制**。一个二元数组`[min, max]`。在`handle`执行后，用于将`path`对应的值强制约束在**绝对值**范围内。仅在**作用域模式**下生效。 |

**`path` 决定的两种执行模式：**

1.  **全局模式 (Global Mode)**: 当 `path` 为 `"*"` 时触发。
  - 规则直接对整个 `workingData` 对象进行操作。
  - `handle` 中的DSL表达式需要自己指定操作的目标路径。
  - `limit` 和 `range` 字段在此模式下**被忽略**。
  - 示例: `好感度池自增` 规则。

2.  **作用域模式 (Scoped Mode)**: 当 `path` 为具体路径时触发 (e.g., `"角色.*.好感度"`)。
  - 规则引擎会首先根据 `path` 查找所有匹配的具体路径 (e.g., `"角色.A.好感度"`, `"角色.B.好感度"`)。
  - 然后，引擎会**遍历每一个具体路径**，将该路径作为“上下文”，分别执行`handle`, `range`, `limit`逻辑。
  - 在此模式下，规则内所有DSL表达式中的通配符 `*` 会按顺序绑定。例如，当 `path` 为 `身体开发等级.*.*` 时，`if` 中的 `$[角色.*.特殊状态.开发经验值.*]` 的第一个 `*` 会与 `path` 的第一个 `*` (角色名) 绑定，第二个 `*` 会与 `path` 的第二个 `*` (身体部位) 绑定。
  - 示例: `限制好感度变化值变化` 规则。

**`handle` 对象详解:**

`handle` 是一个字典，包含一个或多个“处理项”（HandleItem）。

```json
"handle": {
  "处理项名称1": { "order": 0, "op": "...", ... },
  "处理项名称2": { "order": 1, "op": "...", ... }
}
```

- **`key`** 是人类可读的处理项名称 (e.g., "将变化值归零")。
- **`value`** 是一个处理项对象，包含：
  - `order` (number): 处理项内部的执行顺序，数字越小越先执行。
  - `loop` (number): 该处理项的独立循环次数（最大`1000`）。若`if`为假则终止。
  - `if` (string): 该处理项的独立执行条件（DSL表达式）。
  - `op` (string): **核心操作**，一个必须的DSL表达式，定义了具体的数据修改行为。一条`handle`只能有一个`op`。

#### 4. 核心：DSL语法解析

`if` 和 `op` 字段使用一种简单的领域特定语言（DSL）来描述数据操作和判断。

**基本结构:**

DSL表达式被包裹在 `<<tag> ... >` 中，`tag` 通常是 `op` 或 `if`。表达式由多个组件构成，以空格分隔。

**DSL 组件 (DSL Components):**

1.  **路径选择器 (Path Selector)**: `$[path.to.value]`
  - 用于从 `workingData` 中获取或指定一个值。
  - `*` 是通配符，可以匹配任意路径片段。
  - 示例: `$[角色.*.特殊状态.好感度]`

2.  **操作符/函数 (Operator/Function)**: `#[operator]` 或 `#[{func}(...)]`
  - 定义要执行的操作。
  - **赋值操作符**: `#[=]`。**这是所有 `op` 表达式的核心**。
  - **计算操作符**: `#[+]`, `#[-]`, `#[*]`, `#[/]`, `#[%]`, `#[**]` (幂)。
  - **比较/逻辑操作符**: `?[==]`, `?[!=]`, `?[>]`, `?[<]`, `?[>=]`, `?[<=]`, `?[&&]`, `?[||]`。用于 `if` 条件，可使用 `()` 定义优先级。
  - **函数**: `#[{min}(...)]`, `#[{max}(...)]`, `#[{sum}(...)]`, `#[{avg}(...)]`, `#[{floor}(A)]`, `#[{ceil}(A)]`, `#[{abs}(A)]`, `#[{neg}(A)]`, `#[{ln}(A)]`, `#[{log2}(A)]`, `#[{sqrt}(A)]`。

3.  **字面量 (Literal Value)**: `&[{type}value]`
  - 定义一个静态值。`type` 包括 `num`, `str`, `bool`, `null`。
  - 示例: `&[{num}5]` 表示数字 `5`。

4.  **临时变量 (Temporary Variable)**: `@[{scope}name]`
  - 用于在规则执行期间存储和读取临时值。
  - `@[{g}name]`: **全局变量**。在所有规则执行期间都存在。
  - `@[{s}name]`: **作用域变量**。仅在当前规则（Rule Object）执行期间存在。

**表达式求值:**

- **`op` 表达式**: **必须是赋值操作**，遵循 `[目标路径/变量] #[=] [表达式]` 的格式。
  - `<<op> $[好感度池.*] #[=] $[好感度池.*] #[+] &[{num}5] >`
  - **释义**: 将 `好感度池.*` 的值，更新为它**当前的值加上 `5`**。

- **`if` 表达式**: 遵循 `[值1] [比较/逻辑符] [值2]` 的格式。
  - `<<if> ($[经验值] ?[>=] &[{num}100]) ?[&&] ($[等级] ?[<] &[{num}10]) >`
  - **释义**: 判断 `经验值` 是否大于等于 `100` **并且** `等级` 是否小于 `10`。

**操作符优先级 (Operator Precedence):**

DSL表达式严格按照以下优先级（数字越小优先级越高）进行求值：

1.  括号 `( )`
2.  函数调用 `#{func}(...)`
3.  标识符 `$[path]` 和字面量 `&[{type}value]`
4.  一元函数 `ln`, `log2`, `sqrt`, `abs`, `floor`, `ceil`, `neg`
5.  幂运算 `**`
6.  乘、除、模 `*`, `/`, `%`
7.  加、减 `+`, `-`
8.  比较运算 `==`, `!=`, `<`, `>`, `<=`, `>=`
9.  逻辑与 `&&`
10. 逻辑或 `||`
11. 赋值 `=`

#### 5. 执行逻辑与顺序

`EraDataHandler` 严格按照以下步骤处理规则：

1.  **数据准备**: 合并 `snap` 和 `data` 生成 `workingData`。
2.  **规则排序**: 根据所有规则的 `order` 字段，从小到大进行全局排序。
3.  **遍历规则**: 依次执行排序后的每一条规则。
    a. **检查 `enable`**: 如果为 `false`，完全跳过此规则。
    b. **判断模式**: 根据 `path` 是 `"*"` 还是具体路径，进入全局模式或作用域模式。在作用域模式下，引擎会找到所有匹配的实际路径。
    c. **遍历上下文**: （全局模式执行1次，作用域模式对每个匹配路径执行1次）
    i. **执行规则循环 (`loop`)**: 开始循环（默认为1，最大1000次）。
    ii. **检查规则级 `if`**: 如果 `if` 条件存在且结果为 `false`：
    - **执行 `range`** (如果定义了)。
    - **执行 `limit`** (如果定义了)。
    - **`break`**，立即终止此规则的循环，进入下一条规则。
    iii. **执行 `handle`**:
    - 按 `order` 排序 `handle` 中的所有处理项。
    - 依次执行每个处理项，遵循其内部的 `loop` 和 `if`。
    - 执行 `op` 表达式，**立即修改** `workingData`。这个修改对后续的处理项可见。
    iv. **执行 `range`** (如果定义了)。
    v. **执行 `limit`** (如果定义了)。
4.  **生成差异**: 计算最终的 `workingData` 与原始 `snap` 之间的差异（`diff`），并返回。

**核心执行顺序（单次循环内）**: `handle` -> `range` -> `limit`。

#### 6. 实例分析


**示例1: `限制好感度变化值变化` (作用域模式)**

```json
"限制好感度变化值变化": {
  "enable": true,
  "path": "角色.*.特殊状态.好感度变化值",
  "order": 1,
  "handle": {
    "和好感度池取小值": {
      "order": 0,
      "op": "<<op> $[角色.*.特殊状态.好感度变化值] #[=] #[{min}($[角色.*.特殊状态.好感度变化值], $[好感度池.*])] >"
    },
    "减少好感度池": {
      "order": 1,
      "op": "<<op> $[好感度池.*] #[=] $[好感度池.*] #[-] $[角色.*.特殊状态.好感度变化值] >"
    }
  },
  "limit": [-5, 40]
}
```

- **`path`**: `角色.*.特殊状态.好感度变化值` -> 这是一个**作用域规则**。它会分别对每个角色的 `好感度变化值` 执行。
- **`order`**: `1` -> 在 `好感度池自增` (order 0) 之后执行。
- **`handle`**:
  1.  **`和好感度池取小值` (order 0)**: 假设当前处理角色 "A"，`好感度变化值` 为 `50`，`好感度池` 为 `20`。此操作会将角色 "A" 的 `好感度变化值` 从 `50` 修改为 `min(50, 20)`，即 `20`。
  2.  **`减少好感度池` (order 1)**: 接着，它会执行 `好感度池 = 好感度池 - 好感度变化值`。此时 `好感度变化值` 已经是上一步修改后的 `20`。所以 `好感度池` 变为 `20 - 20 = 0`。
- **后续处理**: 在 `handle` 执行完毕后，引擎会继续执行 `range` (此规则未定义) 和 `limit`。
  - **`limit`**: `[-5, 40]` 会检查 `好感度变化值` 的**总变化量**。假设快照中角色 "A" 的 `好感度变化值` 是 `0`，现在是 `20`，变化量为 `+20`。这个值在 `[-5, 40]` 区间内，所以不会被 `limit` 修改。如果 `handle` 导致变化量为 `+50`，`limit` 会将其强制修正为 `+40`。

**示例2: `升级身体开发等级` (带复杂`if`的循环规则)**

```json
"升级身体开发等级": {
  "enable": true,
  "path": "身体开发等级.*.*",
  "order": 4,
  "loop": 10,
  "if": "<<if> $[角色.*.特殊状态.开发经验值.*] ?[>=] #[{floor}(&[{num}7] #[*] #[{ln}($[身体开发等级.*.*] #[+] &[{num}1])] #[+] &[{num}5])] >",
  "handle": {
      "等级提升": {
        "order": 0,
        "op": "<<op> $[身体开发等级.*.*] #[=] $[身体开发等级.*.*] #[+] &[{num}1] >"
      },
      "扣除升级所需经验": {
        "order": 1,
        "op": "<<op> $[角色.*.特殊状态.开发经验值.*] #[=] $[角色.*.特殊状态.开发经验值.*] #[-] #[{floor}(&[{num}7] #[*] #[{ln}($[身体开发等级.*.*])] #[+] &[{num}5])] >"
      }
  }
}
```

-   **`path`**: `"身体开发等级.*.*"` -> **作用域规则**。引擎会遍历所有匹配的路径，例如 `身体开发等级.角色A.胸部`。在处理该路径时，`if` 和 `op` 中的 `*` 会被依次替换为 `角色A` 和 `胸部`。

-   **`loop`**: `10` -> **受控的循环**。这模拟了 `while(condition)` 循环，允许角色在一次操作中连续升级。设置一个具体的数值（如10，规则文件最大支持1000）是一个安全措施，防止无限循环。

-   **`if`**: **循环的守卫条件**。
  -   `<<if> $[角色.*.特殊状态.开发经验值.*] ?[>=] #[{floor}(...)] >`
  -   **整体逻辑**: **如果 "当前部位的经验值" 大于或等于 "升到下一级所需的经验值"，则条件为真，可以升级。**
  -   **左侧**: `$[角色.*.特殊状态.开发经验值.*]` 获取当前作用域下的经验值。
  -   **右侧**: `#[{floor}(&[{num}7] #[*] #[{ln}($[身体开发等级.*.*] #[+] &[{num}1])] #[+] &[{num}5])]` 是DSL版本的升级费用公式：`floor(7 * ln(当前等级 + 1) + 5)`。

-   **`handle`**: **升级操作**。这部分只在 `if` 条件为真时执行。
  -   **`等级提升` (`order: 0`)**: 将当前作用域的等级值加1 (`lv++`)。
  -   **`扣除升级所需经验` (`order: 1`)**: 从经验值中扣除升级费用。
  -   **关键细节**: 注意扣费公式 `#[{ln}($[身体开发等级.*.*])]` 与 `if` 条件中的 `#[{ln}($[身体开发等级.*.*] #[+] &[{num}1])]` 不同。这是因为：
    1.  在 `if` 中，我们判断能否从**当前等级 `lv`** 升到 `lv+1`。
    2.  在 `handle` 中，`等级提升` 操作先执行，等级已经变成了 `lv+1`。
    3.  `扣除升级所需经验` 在之后执行，此时 `$[身体开发等级.*.*]` 获取的是**新等级 `lv+1`**。因此，扣费公式 `floor(7 * ln(lv_new) + 5)` 正好对应升到这个新等级所消耗的费用（该费用基于旧等级 `lv_old` 计算，即 `floor(7 * ln(lv_old + 1) + 5)`）。
    4.  这体现了 `op` 的修改会**立即生效**，并影响同一规则内后续 `handle` 的计算，这是设计复杂逻辑（如升级扣费）的关键。
